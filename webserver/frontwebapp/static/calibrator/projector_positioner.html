<!--
File: projector_positioner.html
Project: FpMED - Framework for Distributed Multiprojection Systems
File Created: Friday, 19th July 2019 11:25:26 pm
Author: Aramis Hornung Moraes (aramishm@gmail.com)
-----
Last Modified: Saturday, 20th July 2019 12:36:04 pm
Modified By: Aramis Hornung Moraes (aramishm@gmail.com>)
-----
Copyright 2014 - 2019 Aramis Hornung Moraes
-->

<!-- Projector calibrator module -->


<!DOCTYPE html>
<html lang="en">

<head>
    <title>Domefy - Projector positioner</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <link type="text/css" rel="stylesheet" href="main.css">
    <style>
        #info {
            position: absolute;
            top: 0px;
            width: 100%;
            padding: 10px;
            box-sizing: border-box;
            text-align: center;
            z-index: 1;
            /* TODO Solve this in HTML */
        }

        #logo {
            position: absolute;
            top: 50px;
            width: 5%;
            padding: 10px;
            box-sizing: border-box;
            text-align: left;
            z-index: 1;
            /* TODO Solve this in HTML */
        }
    </style>
</head>

<body>
    <div id="container"></div>
    <img id="logo" src="../watermark_small.png"></img>
    <div id="info">
        <h2> Projector positioner v0.1 </h2>

        <script>
            // SaveParameters - sends all the mapping data to the backend server
            function SaveParameters() {
                console.log("TODO: needs implementation")
            }

            function degrees_to_radians(degrees) {
                var pi = Math.PI;
                return degrees * (pi / 180);
            }

            var SelectedObject;
            function changeSelRotation() {
                SelectedObject.rotation.x = degrees_to_radians(document.getElementById("rotz").value);
                SelectedObject.rotation.y = degrees_to_radians(document.getElementById("roty").value);
                SelectedObject.rotation.z = degrees_to_radians(document.getElementById("rotx").value);
            }

            function UpdateProjectorRotation() {
                var index = SelectedObject.userData.index - 1;
                changeSelRotation();
                var command = "CPP;PROJROT;";
                command += index + ";";
                command += document.getElementById("rotx").value + ";";
                command += document.getElementById("roty").value + ";";
                command += document.getElementById("rotz").value + ";";
                //console.log(command);
                ajaxPost(command, false, "/setExampleTextMessage")
            }

            function UpdateProjectorFOV() {
                var index = SelectedObject.userData.index - 1;
                var command = "CPP;PROJFOV;";
                command += index + ";";
                command += document.getElementById("fov").value + ";";
                //console.log(command);
                ajaxPost(command, false, "/setExampleTextMessage")
            }
        </script>

        <script type="module">
            var container, stats;
            var camera, scene, renderer;
            var cubes = [];
            var geometry = new THREE.BoxBufferGeometry(3, 3, 3);
            var transformControl;
            var Objects = {};
            // the object beeinge edited at the moment

            init();
            animate();

            function UpdateRanges() {
                document.getElementById("rotx").value = SelectedObject.rotation.z * (180 / Math.PI);
                document.getElementById("roty").value = SelectedObject.rotation.y * (180 / Math.PI);
                document.getElementById("rotz").value = SelectedObject.rotation.x * (180 / Math.PI);
                document.getElementById("fov").value = SelectedObject.userData.fov;
            }

            // UpdateProjectorPosition - Sends commands to the Domefy server to update the projectors position
            function UpdateProjectorPosition() {
                var index = SelectedObject.userData.index - 1;
                var command = "CPP;PROJPOS;";
                command += index + ";";
                command += SelectedObject.position.z + ";";
                command += SelectedObject.position.y + ";";
                command += SelectedObject.position.x + ";";
                console.log(command);
                ajaxPost(command, false, "/setExampleTextMessage")
            }


            function init() {
                container = document.getElementById('container');
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0xf0f0f0);
                camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 10000);
                camera.position.set(0, 250, 1000);
                scene.add(camera);

                scene.add(new THREE.AmbientLight(0xf0f0f0));
                var light = new THREE.SpotLight(0xffffff, 1.5);
                light.position.set(0, 1500, 200);
                light.castShadow = true;
                light.shadow = new THREE.LightShadow(new THREE.PerspectiveCamera(70, 1, 200, 2000));
                light.shadow.bias = - 0.000222;
                light.shadow.mapSize.width = 1024;
                light.shadow.mapSize.height = 1024;
                scene.add(light);

                var planeGeometry = new THREE.PlaneBufferGeometry(2000, 2000);
                planeGeometry.rotateX(- Math.PI / 2);
                var planeMaterial = new THREE.ShadowMaterial({ opacity: 0.2 });
                var plane = new THREE.Mesh(planeGeometry, planeMaterial);
                plane.position.y = - 200;
                plane.receiveShadow = true;
                scene.add(plane);

                var helper = new THREE.GridHelper(2000, 100);
                helper.position.y = - 199;
                helper.material.opacity = 0.25;
                helper.material.transparent = true;
                scene.add(helper);

                renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.setSize(window.innerWidth, window.innerHeight);
                renderer.shadowMap.enabled = true;
                container.appendChild(renderer.domElement);
                stats = new Stats();
                container.appendChild(stats.dom);

                // Controls
                var controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.damping = 0.2;
                controls.addEventListener('change', render);
                controls.addEventListener('start', function () {
                    cancelHideTransform();
                });

                controls.addEventListener('end', function () {
                    delayHideTransform();
                });

                transformControl = new THREE.TransformControls(camera, renderer.domElement);
                transformControl.addEventListener('change', render);
                transformControl.addEventListener('dragging-changed', function (event) {
                    controls.enabled = !event.value;
                });

                scene.add(transformControl);
                // Hiding transform situation is a little in a mess :()
                transformControl.addEventListener('change', function () {
                    cancelHideTransform();
                    UpdateProjectorPosition();
                });

                transformControl.addEventListener('mouseDown', function () {
                    cancelHideTransform();
                });

                transformControl.addEventListener('mouseUp', function () {
                    delayHideTransform();
                });

                var dragcontrols = new THREE.DragControls(cubes, camera, renderer.domElement);
                dragcontrols.enabled = false;
                dragcontrols.addEventListener('hoveron', function (event) {
                    transformControl.attach(event.object);
                    SelectedObject = event.object;
                    UpdateRanges();
                    cancelHideTransform();
                });
                dragcontrols.addEventListener('hoveroff', function () {
                    delayHideTransform();
                });

                window.addEventListener('resize', onWindowResize, false);



                window.addEventListener('keydown', function (event) {
                    switch (event.keyCode) {
                        case 81: // Q
                            transformControl.setSpace(transformControl.space === "local" ? "world" : "local");
                            break;
                        case 17: // Ctrl
                            transformControl.setTranslationSnap(50);
                            transformControl.setRotationSnap(degrees_to_radians(15));
                            break;
                        case 87: // W
                            transformControl.setMode("translate");
                            break;
                        case 69: // E
                            transformControl.setMode("rotate");
                            break;
                        case 82: // R
                            transformControl.setMode("scale");
                            break;
                    }
                });
                window.addEventListener('keyup', function (event) {
                    switch (event.keyCode) {
                        case 17: // Ctrl
                            transformControl.setTranslationSnap(null);
                            transformControl.setRotationSnap(null);
                            break;
                    }
                });

                var hiding;

                function delayHideTransform() {
                    cancelHideTransform();
                    hideTransform();
                }
                function hideTransform() {
                    hiding = setTimeout(function () {
                        transformControl.detach(transformControl.object);
                    }, 2500);
                }

                function cancelHideTransform() {
                    if (hiding) clearTimeout(hiding);
                }


                // Get projector info from backend server
                var projConfs = GetConfigurationJSON();


                var geometry = new THREE.BufferGeometry();
                for (var i = 0; i < projConfs.presets.length; i++) {
                    var obj = addObjectObject(projConfs.presets[i].proj_position,
                        projConfs.presets[i].proj_rotation,
                        i + 1);

                    obj.userData.fov = projConfs.presets[i].fov;
                }

            }
            function addObjectObject(position, rotation, index) {
                var material = new THREE.MeshLambertMaterial({ color: Math.random() * 0xffffff });
                var object = new THREE.Mesh(geometry, material);
                if (position && rotation) {
                    object.position.x = position.z;
                    object.position.y = position.y;
                    object.position.z = position.x;

                    object.set
                    object.rotation.x = degrees_to_radians(rotation.z);
                    object.rotation.y = degrees_to_radians(rotation.y);
                    object.rotation.z = degrees_to_radians(rotation.x);
                } else {
                    object.position.x = Math.random() * 1000 - 500;
                    object.position.y = Math.random() * 600;
                    object.position.z = Math.random() * 800 - 400;

                }

                // helps us identify what projector we are modifying when sending commands to Domefy
                if (Number(index)) {
                    object.userData.index = Number(index);
                }

                object.castShadow = true;
                object.receiveShadow = true;
                scene.add(object);
                cubes.push(object);
                return object;
            }

            function animate() {
                requestAnimationFrame(animate);
                render();
                stats.update();
            }

            function render() {
                renderer.render(scene, camera);
            }

            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                render();
            }
        </script>

        <div>
            <p>Rotation Contols</p>
            X: <input style="width: 140 px" type="range" id="rotx" min="0" max="360" step="0.01"
                oninput="UpdateProjectorRotation()">
            Y: <input style="width: 140 px" type="range" id="roty" min="0" max="360" step="0.01"
                oninput="UpdateProjectorRotation()">
            Z: <input style="width: 140 px" type="range" id="rotz" min="0" max="360" step="0.01"
                oninput="UpdateProjectorRotation()">
            FOV: <input style="width: 140 px" type="range" id="fov" min="0" max="360" step="0.01"
                oninput="UpdateProjectorFOV()">
        </div>
        <input type="text" id="fileName" required minlength="4" maxlength="40"><button type="button"
            onclick="SaveParameters()">Save parameters</button>

        <script src="../threejs/three.js"></script>
        <script src="../threejs/js/libs/stats.min.js"></script>
        <script src="../threejs/js/libs/dat.gui.min.js"></script>
        <script src="../threejs/js/controls/DragControls.js"></script>
        <script src="../threejs/js/controls/OrbitControls.js"></script>
        <script src="../threejs/js/controls/TransformControls.js"></script>
        <script src="../config.js"></script>
        <script src="../jquery/jquery.min.js"></script>
        <script src="../domefy/utils.js"></script>
    </div>
</body>

</html>