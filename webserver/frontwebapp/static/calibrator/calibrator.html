<!--
File: calibrator.html
Project: FpMED - Framework for Distributed Multiprojection Systems
File Created: Tuesday, 2nd July 2019 3:00:17 pm
Author: Aramis Hornung Moraes (aramishm@gmail.com)
-----
Last Modified: Tuesday, 2nd July 2019 3:00:26 pm
Modified By: Aramis Hornung Moraes (aramishm@gmail.com>)
-----
Copyright 2014 - 2019 Aramis Hornung Moraes
-->

<!DOCTYPE html>
<html lang="en">

<head>
  <title>Calibrator</title>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0" />
  <style>
    body {
      background-color: #ffe2e294;
    }
  </style>

  <script src="../config.js"></script>
</head>

<!-- This tool is used to set the deformation of the final projection, in a point-to-point basis. -->
<script src="../jquery/jquery.min.js"></script>
<script src="../jquery/jquery-ui.js"></script>
<script>
  var indexCounter = 0;
</script>

<body onload="AddGridVertexes()">
  <P>
    <table>
      <tr>
        <th>Mesh Calibrator</th>
      </tr>

      <tr>
        <td>
          <table>
            <tr>
              <th>Projector to adjust</th>
              <th>Vertex grab mode</th>
            </tr>
            <tr>
              <td>
                <br />
                Projector:
                <select>
                  <!-- TODO: load from file or a handle -->
                  <option value="1">DS 1</option>
                  <option value="2">DS 2</option>
                  <option value="3">DS 3</option>
                  <option value="4">DS 4</option>
                </select>
              </td>
              <td>
                <br />
                Picking type:
                <select onchange="pickingChanged(this.value)">
                  <option value="NEIGHBOURS">Neighbours</option>
                  <option value="SINGLE">Single</option>
                </select>
                <br />
              </td>
            </tr>
          </table>
        </td>
      </tr>

      <tr>
        <td>
          <br />
          <br />
          <div class="col-sm-7 text">
            <div class="description">
              <div id="myDiagramDiv" class="bgimg" draggable="true"
                style="width:800px; height:800px; background-color: #DAE4E4;"></div>
            </div>
          </div>
        </td>
      </tr>
      <!-- <td>
        <div class="col-sm-7 text">
          <h3>Vision position - XZ plane</h3>
          <div>
            <div id="DragXZgrid" class="bgimg" draggable="true"
              style="width:600px; height:400px; background-color: #DAE4E4;"></div>
          </div>
        </div>
      </td> -->
    </table>
  </P>

</body>

<style type="text/css">
  .bgimg {
    background-image: url("../assets/images/grid-reference.png");
  }
</style>

<script>
  // class with transformations
  function Vert(idx) {
    this.index = idx;
    this.x = 0;
    this.y = 0;
  }

  affecRadius = 2; // radius of neigbours affected
  moveNeighbours = true;
  var spacing = 45; // pixels
  // matrix to translate the visible mesh vertex to actual index on buffer
  var transMatrix = [
    [68, 43, 42, 7, 6, 55, 54, 3, 2],
    [67, 40, 41, 4, 5, 52, 53, 0, 1],
    [65, 47, 46, 51, 50, 59, 58, 63, 62],
    [64, 44, 45, 48, 49, 56, 57, 60, 61],
    [66, 31, 30, 11, 10, 19, 18, 15, 14],
    [76, 28, 29, 8, 9, 16, 17, 12, 13],
    [73, 35, 34, 39, 38, 23, 22, 27, 26],
    [72, 32, 33, 36, 37, 20, 21, 24, 25],
    [74, 75, 69, 70, 71, 80, 77, 78, 79]
  ];

  var vertices = [
    [0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0],
    [0, 0, 0, 0, 0, 0, 0, 0, 0]
  ];

  function pickingChanged(value) {
    if (value == "NEIGHBOURS") {
      moveNeighbours = true;
    } else if (value == "SINGLE") {
      moveNeighbours = false;
    }
  }

  function clamp(num, min, max) {
    return num <= min ? min : num >= max ? max : num;
  }

  // add image to control the mesh vertexes,
  // X, Y = calibrator coordinates
  // id, vertex index
  function AddMeshPicker(x, y, id) {
    var img = document.createElement("img");
    img.src = "../assets/images/marker.png";
    img.height = 7;
    img.width = 7;

    // It needs the following normalization
    img.style.top = y - img.height + "px"; // magic equation to normalize visual position with the image parameter
    img.style.left = x - (1 + indexCounter * img.width) + "px"; // another magic normalization to align the visual element with its parameters

    var i = Math.floor(indexCounter / 9);
    var j = Math.floor(indexCounter % 9);
    img.setAttribute("index", Number(id)); // ARAMIS: Uses this to know what vertex we are dealing with

    // value that  indicates the original position relative to parent element
    img.setAttribute("orgigX", x); // original position X
    img.setAttribute("orgigY", y); // original position Y

    // current position relative to its origin
    img.setAttribute("currPosX", 0);
    img.setAttribute("currPosY", 0);

    // current position subtracted by last interation of position
    img.setAttribute("lastPosX", 0);
    img.setAttribute("lastPosY", 0);

    // the matrix index, to help localize adjacent elements
    // yes it is flipped, because, visually, it is builted flipped.
    img.setAttribute("i", j);
    img.setAttribute("j", i);

    vertices[j][i] = img; // also visually flipped
    indexCounter++;
    document.getElementById("myDiagramDiv").appendChild(img);

    $(img).draggable({
      drag: function () {
        var $this = $(this);
        var thisPos = $this.position();
        var parentPos = $this.parent().position();
        var x = thisPos.left - parentPos.left;
        var y = thisPos.top - parentPos.top;
        //   console.log(
        //     img.getAttribute("index", indexCounter) + " " + x + ", " + y
        //   );

        var selecIndex = Number(img.getAttribute("index"));

        // current position
        var cpx = 0;
        var cpy = 0;

        // the movement relative to last iteration
        var dpx = 0;
        var dpy = 0;

        cpx = x - img.getAttribute("orgigX");
        cpy = y - img.getAttribute("orgigY");

        dpx = cpx - img.getAttribute("lastPosX");
        dpy = cpy - img.getAttribute("lastPosY");

        img.setAttribute("lastPosX", img.getAttribute("currPosX"));
        img.setAttribute("lastPosY", img.getAttribute("currPosY"));

        img.setAttribute("currPosX", cpx);
        img.setAttribute("currPosY", cpy);

        var cmd2Send = ""; // the command we will send on the network
        var affectedAdjs = [];

        // multiple vertexes
        if (moveNeighbours) {
          var i0, j0;
          i0 = img.getAttribute("i");
          j0 = img.getAttribute("j");
          var affectFactor = 8; // just guessing

          var nAffecAjs = 1; // the center one counts as a node
          v = new Vert(transMatrix[i0][j0]);
          v.x = cpx;
          v.y = cpy;
          affectedAdjs.push(v);
          // affect all nodes arround the selected one
          for (i = i0 - affecRadius; i <= Number(i0) + affecRadius; ++i) {
            for (j = j0 - affecRadius; j <= Number(j0) + affecRadius; ++j) {
              // normalize indexes
              var ni = clamp(i, 0, 8);
              var nj = clamp(j, 0, 8);

              // only affect adjacent nodes.
              if (ni != i0 || nj != j0) {
                // calulate how much it will affect
                var xscore, yscore;
                xscore = Math.abs(ni - i0);
                yscore = Math.abs(nj - j0);
                var faktor = xscore + yscore;

                // alter node position and store for sending
                var imag = vertices[ni][nj];

                var pcXimag, pcYimag;
                pcXimag = Number(imag.getAttribute("currPosX"));
                pcYimag = Number(imag.getAttribute("currPosY"));
                faktor += 2; // i dont know why 2, if only 2 it moves the same speed the selected node
                clamp(faktor, 2, faktor);
                pcXimag = pcXimag + dpx / faktor;
                pcYimag = pcYimag + dpy / faktor;
                imag.setAttribute("currPosX", pcXimag);
                imag.setAttribute("currPosY", pcYimag);
                var idx = imag.getAttribute("index");
                var origX, origY;
                origX = imag.getAttribute("orgigX");
                origY = imag.getAttribute("orgigY");

                imag.style.left =
                  Math.floor(origX) +
                  pcXimag +
                  -(1 + idx * img.width) + // normalization
                  "px";
                imag.style.top =
                  Math.floor(origY) +
                  pcYimag +
                  -img.height + // normalization
                  "px";

                // store in a vector, that later we will send to the C++ app
                ++nAffecAjs;
                v = new Vert(transMatrix[ni][nj]);
                v.x = pcXimag;
                v.y = pcYimag;
                affectedAdjs.push(v);
              }
            }
          }
        }

        // command composition

        // get the selected object, with all those sweet parameters inside userData
        var SelectedObject = parent.SelectedObject;
        // single vertex
        cmd2Send += "CPP;";
        if (!moveNeighbours) {
          cmd2Send +=
            "VRTX;"; // single vertex transformation

          // check parent window if have the information of selected projector object
          if (SelectedObject) {
            cmd2Send += SelectedObject.userData.index + ";";
          } else {
            cmd2Send += "0;";
          }

          // line and column are inverted
          var vertIndex = transMatrix[Math.floor(selecIndex % 9)][Math.floor(selecIndex / 9)];

          cmd2Send += vertIndex +
            ";" +
            img.getAttribute("currPosX") +
            ";" +
            img.getAttribute("currPosY") +
            ";";
        } else {
          cmd2Send += "VRTXBATCH;";

          // check parent window if have the information of selected projector object
          if (SelectedObject) {
            cmd2Send += SelectedObject.userData.index + ";";
          } else {
            cmd2Send += "0;";
          }

          cmd2Send += + affectedAdjs.length + ";";

          for (vi = 0; vi < affectedAdjs.length; ++vi) {
            cmd2Send +=
              affectedAdjs[vi].index +
              ";" +
              affectedAdjs[vi].x +
              ";" +
              affectedAdjs[vi].y +
              ";";
          }
          transMatrix[Math.floor(selecIndex % 9)][ // line and column are inverted
            Math.floor(selecIndex / 9)
          ] +
            ";" +
            img.getAttribute("currPosX") +
            ";" +
            img.getAttribute("currPosY") +
            ";";
        }

        // save mesh to selected object
        if (SelectedObject) {
          for (var i = 0; i < 9; ++i) {
            for (var j = 0; j < 9; ++j) {
              var xx = vertices[j][i].getAttribute("currPosX");
              var yy = vertices[j][i].getAttribute("currPosY");
              // by experimenting, I had to invert it.
              SelectedObject.userData.morphMesh[j][i].x = Number(xx);
              SelectedObject.userData.morphMesh[j][i].y = Number(yy);
            }
          }
        }


        //console.log(cmd2Send); // debug
        sendCommand(cmd2Send, false);
      }
    });
  }

  // SetMorphGrid - Parent calls this function to reset the morph grid according to the selected projector
  // function SetMorphGrid() {
  //   var SelectedObject = parent.SelectedObject;

  //   if (SelectedObject) {
  //     for (var i = 0; i < 9; ++i) {
  //       for (var j = 0; j < 9; ++j) {
  //         var newx = SelectedObject.userData.morphMesh[i][j].x;
  //         var newy = SelectedObject.userData.morphMesh[i][j].y;

  //         var img = vertices[i][j];
  //         img.setAttribute("currPosX", newx);
  //         img.setAttribute("currPosY", newy);
  //         img.setAttribute("lastPosX", newx);
  //         img.setAttribute("lastPosY", newy);

  //         // It needs the following normalization
  //         var idxCount = (i * 9 + j);

  //         // It needs the following normalization
  //         img.style.top =
  //           Math.floor(img.getAttribute("orgigY")) +
  //           newy +
  //           -img.height +
  //           "px";

  //         //img.style.left = newx - (1 + indexCounter * img.width) + "px";
  //       }
  //     }
  //   }
  // }

  // Populate the initial grid
  function AddGridVertexes() {
    // add baground

    for (i = 0; i < 9; ++i) {
      for (j = 0; j < 9; ++j) {
        var id = 0;
        id = i * 9 + j;
        AddMeshPicker(i * spacing, j * spacing, id);
      }
    }

    //AddXZTranslation();
    //  console.log("grid loaded ");
  }

  function sendCommand(data, sync = true) {
    $.ajax({
      type: "POST",
      //the url where you want to sent the userName and password to
      url: "http://" + serviceIPPort + "/setExampleTextMessage",
      dataType: "json",
      async: sync,
      //json object to sent to the authentication url
      data: '{"command": "' + data + '"}',
      success: function () {
        // alert("Thanks!");
      }
    });
  }
</script>

</html>